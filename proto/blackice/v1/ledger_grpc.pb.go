// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: blackice/proto/blackice/v1/ledger.proto

package blackicev1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	LedgerService_AppendEntry_FullMethodName        = "/blackice.v1.LedgerService/AppendEntry"
	LedgerService_GetEntry_FullMethodName           = "/blackice.v1.LedgerService/GetEntry"
	LedgerService_GetEntries_FullMethodName         = "/blackice.v1.LedgerService/GetEntries"
	LedgerService_VerifyEntry_FullMethodName        = "/blackice.v1.LedgerService/VerifyEntry"
	LedgerService_GetLedgerState_FullMethodName     = "/blackice.v1.LedgerService/GetLedgerState"
	LedgerService_ForceReSignEntries_FullMethodName = "/blackice.v1.LedgerService/ForceReSignEntries"
	LedgerService_ReplicateEntries_FullMethodName   = "/blackice.v1.LedgerService/ReplicateEntries"
	LedgerService_RequestVote_FullMethodName        = "/blackice.v1.LedgerService/RequestVote"
	LedgerService_AppendRaftEntries_FullMethodName  = "/blackice.v1.LedgerService/AppendRaftEntries"
)

// LedgerServiceClient is the client API for LedgerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// LedgerService provides a tamper-evident, auditable log of critical events and state changes.
// It uses Raft for consensus and Merkle trees for integrity.
type LedgerServiceClient interface {
	// AppendEntry appends a new entry to the ledger. Requires consensus.
	AppendEntry(ctx context.Context, in *AppendEntryRequest, opts ...grpc.CallOption) (*AppendEntryResponse, error)
	// GetEntry retrieves a specific ledger entry by its ID or index.
	GetEntry(ctx context.Context, in *GetEntryRequest, opts ...grpc.CallOption) (*GetEntryResponse, error)
	// GetEntries retrieves a range of ledger entries.
	GetEntries(ctx context.Context, in *GetEntriesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LedgerEntry], error)
	// VerifyEntry verifies the integrity of a ledger entry using its Merkle proof.
	VerifyEntry(ctx context.Context, in *VerifyEntryRequest, opts ...grpc.CallOption) (*VerificationResponse, error)
	// GetLedgerState returns the current state of the ledger (e.g., current term, commit index).
	GetLedgerState(ctx context.Context, in *LedgerStateRequest, opts ...grpc.CallOption) (*LedgerStateResponse, error)
	// ForceReSign (Admin) re-signs ledger entries, e.g., after a master key rotation.
	// This is a highly privileged operation.
	ForceReSignEntries(ctx context.Context, in *ForceReSignRequest, opts ...grpc.CallOption) (*ForceReSignResponse, error)
	// ReplicateEntries is used for internal replication between ledger nodes.
	// Typically part of the Raft implementation but exposed for monitoring/control.
	ReplicateEntries(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[LedgerEntry, ReplicationAck], error)
	// RequestVote is part of the Raft consensus protocol.
	RequestVote(ctx context.Context, in *RequestVoteArgs, opts ...grpc.CallOption) (*RequestVoteReply, error)
	// AppendEntries (Raft) is part of the Raft consensus protocol for log replication.
	AppendRaftEntries(ctx context.Context, in *AppendRaftEntriesArgs, opts ...grpc.CallOption) (*AppendRaftEntriesReply, error)
}

type ledgerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLedgerServiceClient(cc grpc.ClientConnInterface) LedgerServiceClient {
	return &ledgerServiceClient{cc}
}

func (c *ledgerServiceClient) AppendEntry(ctx context.Context, in *AppendEntryRequest, opts ...grpc.CallOption) (*AppendEntryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AppendEntryResponse)
	err := c.cc.Invoke(ctx, LedgerService_AppendEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerServiceClient) GetEntry(ctx context.Context, in *GetEntryRequest, opts ...grpc.CallOption) (*GetEntryResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetEntryResponse)
	err := c.cc.Invoke(ctx, LedgerService_GetEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerServiceClient) GetEntries(ctx context.Context, in *GetEntriesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LedgerEntry], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LedgerService_ServiceDesc.Streams[0], LedgerService_GetEntries_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[GetEntriesRequest, LedgerEntry]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LedgerService_GetEntriesClient = grpc.ServerStreamingClient[LedgerEntry]

func (c *ledgerServiceClient) VerifyEntry(ctx context.Context, in *VerifyEntryRequest, opts ...grpc.CallOption) (*VerificationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VerificationResponse)
	err := c.cc.Invoke(ctx, LedgerService_VerifyEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerServiceClient) GetLedgerState(ctx context.Context, in *LedgerStateRequest, opts ...grpc.CallOption) (*LedgerStateResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LedgerStateResponse)
	err := c.cc.Invoke(ctx, LedgerService_GetLedgerState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerServiceClient) ForceReSignEntries(ctx context.Context, in *ForceReSignRequest, opts ...grpc.CallOption) (*ForceReSignResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ForceReSignResponse)
	err := c.cc.Invoke(ctx, LedgerService_ForceReSignEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerServiceClient) ReplicateEntries(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[LedgerEntry, ReplicationAck], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LedgerService_ServiceDesc.Streams[1], LedgerService_ReplicateEntries_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[LedgerEntry, ReplicationAck]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LedgerService_ReplicateEntriesClient = grpc.BidiStreamingClient[LedgerEntry, ReplicationAck]

func (c *ledgerServiceClient) RequestVote(ctx context.Context, in *RequestVoteArgs, opts ...grpc.CallOption) (*RequestVoteReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RequestVoteReply)
	err := c.cc.Invoke(ctx, LedgerService_RequestVote_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *ledgerServiceClient) AppendRaftEntries(ctx context.Context, in *AppendRaftEntriesArgs, opts ...grpc.CallOption) (*AppendRaftEntriesReply, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AppendRaftEntriesReply)
	err := c.cc.Invoke(ctx, LedgerService_AppendRaftEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LedgerServiceServer is the server API for LedgerService service.
// All implementations must embed UnimplementedLedgerServiceServer
// for forward compatibility.
//
// LedgerService provides a tamper-evident, auditable log of critical events and state changes.
// It uses Raft for consensus and Merkle trees for integrity.
type LedgerServiceServer interface {
	// AppendEntry appends a new entry to the ledger. Requires consensus.
	AppendEntry(context.Context, *AppendEntryRequest) (*AppendEntryResponse, error)
	// GetEntry retrieves a specific ledger entry by its ID or index.
	GetEntry(context.Context, *GetEntryRequest) (*GetEntryResponse, error)
	// GetEntries retrieves a range of ledger entries.
	GetEntries(*GetEntriesRequest, grpc.ServerStreamingServer[LedgerEntry]) error
	// VerifyEntry verifies the integrity of a ledger entry using its Merkle proof.
	VerifyEntry(context.Context, *VerifyEntryRequest) (*VerificationResponse, error)
	// GetLedgerState returns the current state of the ledger (e.g., current term, commit index).
	GetLedgerState(context.Context, *LedgerStateRequest) (*LedgerStateResponse, error)
	// ForceReSign (Admin) re-signs ledger entries, e.g., after a master key rotation.
	// This is a highly privileged operation.
	ForceReSignEntries(context.Context, *ForceReSignRequest) (*ForceReSignResponse, error)
	// ReplicateEntries is used for internal replication between ledger nodes.
	// Typically part of the Raft implementation but exposed for monitoring/control.
	ReplicateEntries(grpc.BidiStreamingServer[LedgerEntry, ReplicationAck]) error
	// RequestVote is part of the Raft consensus protocol.
	RequestVote(context.Context, *RequestVoteArgs) (*RequestVoteReply, error)
	// AppendEntries (Raft) is part of the Raft consensus protocol for log replication.
	AppendRaftEntries(context.Context, *AppendRaftEntriesArgs) (*AppendRaftEntriesReply, error)
	mustEmbedUnimplementedLedgerServiceServer()
}

// UnimplementedLedgerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLedgerServiceServer struct{}

func (UnimplementedLedgerServiceServer) AppendEntry(context.Context, *AppendEntryRequest) (*AppendEntryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppendEntry not implemented")
}
func (UnimplementedLedgerServiceServer) GetEntry(context.Context, *GetEntryRequest) (*GetEntryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEntry not implemented")
}
func (UnimplementedLedgerServiceServer) GetEntries(*GetEntriesRequest, grpc.ServerStreamingServer[LedgerEntry]) error {
	return status.Errorf(codes.Unimplemented, "method GetEntries not implemented")
}
func (UnimplementedLedgerServiceServer) VerifyEntry(context.Context, *VerifyEntryRequest) (*VerificationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerifyEntry not implemented")
}
func (UnimplementedLedgerServiceServer) GetLedgerState(context.Context, *LedgerStateRequest) (*LedgerStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLedgerState not implemented")
}
func (UnimplementedLedgerServiceServer) ForceReSignEntries(context.Context, *ForceReSignRequest) (*ForceReSignResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForceReSignEntries not implemented")
}
func (UnimplementedLedgerServiceServer) ReplicateEntries(grpc.BidiStreamingServer[LedgerEntry, ReplicationAck]) error {
	return status.Errorf(codes.Unimplemented, "method ReplicateEntries not implemented")
}
func (UnimplementedLedgerServiceServer) RequestVote(context.Context, *RequestVoteArgs) (*RequestVoteReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestVote not implemented")
}
func (UnimplementedLedgerServiceServer) AppendRaftEntries(context.Context, *AppendRaftEntriesArgs) (*AppendRaftEntriesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppendRaftEntries not implemented")
}
func (UnimplementedLedgerServiceServer) mustEmbedUnimplementedLedgerServiceServer() {}
func (UnimplementedLedgerServiceServer) testEmbeddedByValue()                       {}

// UnsafeLedgerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LedgerServiceServer will
// result in compilation errors.
type UnsafeLedgerServiceServer interface {
	mustEmbedUnimplementedLedgerServiceServer()
}

func RegisterLedgerServiceServer(s grpc.ServiceRegistrar, srv LedgerServiceServer) {
	// If the following call pancis, it indicates UnimplementedLedgerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LedgerService_ServiceDesc, srv)
}

func _LedgerService_AppendEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).AppendEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_AppendEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).AppendEntry(ctx, req.(*AppendEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerService_GetEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).GetEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_GetEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).GetEntry(ctx, req.(*GetEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerService_GetEntries_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetEntriesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LedgerServiceServer).GetEntries(m, &grpc.GenericServerStream[GetEntriesRequest, LedgerEntry]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LedgerService_GetEntriesServer = grpc.ServerStreamingServer[LedgerEntry]

func _LedgerService_VerifyEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VerifyEntryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).VerifyEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_VerifyEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).VerifyEntry(ctx, req.(*VerifyEntryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerService_GetLedgerState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LedgerStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).GetLedgerState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_GetLedgerState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).GetLedgerState(ctx, req.(*LedgerStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerService_ForceReSignEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ForceReSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).ForceReSignEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_ForceReSignEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).ForceReSignEntries(ctx, req.(*ForceReSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerService_ReplicateEntries_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LedgerServiceServer).ReplicateEntries(&grpc.GenericServerStream[LedgerEntry, ReplicationAck]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type LedgerService_ReplicateEntriesServer = grpc.BidiStreamingServer[LedgerEntry, ReplicationAck]

func _LedgerService_RequestVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestVoteArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).RequestVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_RequestVote_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).RequestVote(ctx, req.(*RequestVoteArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _LedgerService_AppendRaftEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendRaftEntriesArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LedgerServiceServer).AppendRaftEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LedgerService_AppendRaftEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LedgerServiceServer).AppendRaftEntries(ctx, req.(*AppendRaftEntriesArgs))
	}
	return interceptor(ctx, in, info, handler)
}

// LedgerService_ServiceDesc is the grpc.ServiceDesc for LedgerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LedgerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "blackice.v1.LedgerService",
	HandlerType: (*LedgerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AppendEntry",
			Handler:    _LedgerService_AppendEntry_Handler,
		},
		{
			MethodName: "GetEntry",
			Handler:    _LedgerService_GetEntry_Handler,
		},
		{
			MethodName: "VerifyEntry",
			Handler:    _LedgerService_VerifyEntry_Handler,
		},
		{
			MethodName: "GetLedgerState",
			Handler:    _LedgerService_GetLedgerState_Handler,
		},
		{
			MethodName: "ForceReSignEntries",
			Handler:    _LedgerService_ForceReSignEntries_Handler,
		},
		{
			MethodName: "RequestVote",
			Handler:    _LedgerService_RequestVote_Handler,
		},
		{
			MethodName: "AppendRaftEntries",
			Handler:    _LedgerService_AppendRaftEntries_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetEntries",
			Handler:       _LedgerService_GetEntries_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ReplicateEntries",
			Handler:       _LedgerService_ReplicateEntries_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "blackice/proto/blackice/v1/ledger.proto",
}
