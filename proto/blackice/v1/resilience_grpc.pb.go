// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: blackice/proto/blackice/v1/resilience.proto

package blackicev1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ResilienceService_StoreObject_FullMethodName                 = "/blackice.v1.ResilienceService/StoreObject"
	ResilienceService_RetrieveObject_FullMethodName              = "/blackice.v1.ResilienceService/RetrieveObject"
	ResilienceService_DeleteObject_FullMethodName                = "/blackice.v1.ResilienceService/DeleteObject"
	ResilienceService_GetObjectStatus_FullMethodName             = "/blackice.v1.ResilienceService/GetObjectStatus"
	ResilienceService_RepairObject_FullMethodName                = "/blackice.v1.ResilienceService/RepairObject"
	ResilienceService_UpdateObjectPlacementPolicy_FullMethodName = "/blackice.v1.ResilienceService/UpdateObjectPlacementPolicy"
	ResilienceService_GetStorageNodeHealth_FullMethodName        = "/blackice.v1.ResilienceService/GetStorageNodeHealth"
)

// ResilienceServiceClient is the client API for ResilienceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ResilienceService manages distributed data resilience through sharding,
// replication, and reconstruction across decentralized networks (Storj, IPFS).
type ResilienceServiceClient interface {
	// StoreObject encrypts, shards, and distributes an object across the network.
	StoreObject(ctx context.Context, in *StoreObjectRequest, opts ...grpc.CallOption) (*StoreObjectResponse, error)
	// RetrieveObject reconstructs and decrypts an object from its distributed shards.
	RetrieveObject(ctx context.Context, in *RetrieveObjectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ObjectChunk], error)
	// DeleteObject marks an object for deletion and eventually removes its shards.
	DeleteObject(ctx context.Context, in *DeleteObjectRequest, opts ...grpc.CallOption) (*ResilienceOperationResponse, error)
	// GetObjectStatus retrieves the current status of a distributed object (e.g., health, shard locations).
	GetObjectStatus(ctx context.Context, in *GetObjectStatusRequest, opts ...grpc.CallOption) (*GetObjectStatusResponse, error)
	// RepairObject initiates a repair process for a potentially degraded object (e.g., missing shards).
	RepairObject(ctx context.Context, in *RepairObjectRequest, opts ...grpc.CallOption) (*ResilienceOperationResponse, error)
	// UpdateObjectPlacementPolicy updates the placement policy for an object or a class of objects.
	UpdateObjectPlacementPolicy(ctx context.Context, in *UpdatePlacementPolicyRequest, opts ...grpc.CallOption) (*ResilienceOperationResponse, error)
	// GetStorageNodeHealth allows querying health of individual storage nodes participating in Storj/IPFS.
	GetStorageNodeHealth(ctx context.Context, in *StorageNodeHealthRequest, opts ...grpc.CallOption) (*StorageNodeHealthResponse, error)
}

type resilienceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewResilienceServiceClient(cc grpc.ClientConnInterface) ResilienceServiceClient {
	return &resilienceServiceClient{cc}
}

func (c *resilienceServiceClient) StoreObject(ctx context.Context, in *StoreObjectRequest, opts ...grpc.CallOption) (*StoreObjectResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StoreObjectResponse)
	err := c.cc.Invoke(ctx, ResilienceService_StoreObject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resilienceServiceClient) RetrieveObject(ctx context.Context, in *RetrieveObjectRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ObjectChunk], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ResilienceService_ServiceDesc.Streams[0], ResilienceService_RetrieveObject_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[RetrieveObjectRequest, ObjectChunk]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ResilienceService_RetrieveObjectClient = grpc.ServerStreamingClient[ObjectChunk]

func (c *resilienceServiceClient) DeleteObject(ctx context.Context, in *DeleteObjectRequest, opts ...grpc.CallOption) (*ResilienceOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResilienceOperationResponse)
	err := c.cc.Invoke(ctx, ResilienceService_DeleteObject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resilienceServiceClient) GetObjectStatus(ctx context.Context, in *GetObjectStatusRequest, opts ...grpc.CallOption) (*GetObjectStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetObjectStatusResponse)
	err := c.cc.Invoke(ctx, ResilienceService_GetObjectStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resilienceServiceClient) RepairObject(ctx context.Context, in *RepairObjectRequest, opts ...grpc.CallOption) (*ResilienceOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResilienceOperationResponse)
	err := c.cc.Invoke(ctx, ResilienceService_RepairObject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resilienceServiceClient) UpdateObjectPlacementPolicy(ctx context.Context, in *UpdatePlacementPolicyRequest, opts ...grpc.CallOption) (*ResilienceOperationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResilienceOperationResponse)
	err := c.cc.Invoke(ctx, ResilienceService_UpdateObjectPlacementPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resilienceServiceClient) GetStorageNodeHealth(ctx context.Context, in *StorageNodeHealthRequest, opts ...grpc.CallOption) (*StorageNodeHealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(StorageNodeHealthResponse)
	err := c.cc.Invoke(ctx, ResilienceService_GetStorageNodeHealth_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ResilienceServiceServer is the server API for ResilienceService service.
// All implementations must embed UnimplementedResilienceServiceServer
// for forward compatibility.
//
// ResilienceService manages distributed data resilience through sharding,
// replication, and reconstruction across decentralized networks (Storj, IPFS).
type ResilienceServiceServer interface {
	// StoreObject encrypts, shards, and distributes an object across the network.
	StoreObject(context.Context, *StoreObjectRequest) (*StoreObjectResponse, error)
	// RetrieveObject reconstructs and decrypts an object from its distributed shards.
	RetrieveObject(*RetrieveObjectRequest, grpc.ServerStreamingServer[ObjectChunk]) error
	// DeleteObject marks an object for deletion and eventually removes its shards.
	DeleteObject(context.Context, *DeleteObjectRequest) (*ResilienceOperationResponse, error)
	// GetObjectStatus retrieves the current status of a distributed object (e.g., health, shard locations).
	GetObjectStatus(context.Context, *GetObjectStatusRequest) (*GetObjectStatusResponse, error)
	// RepairObject initiates a repair process for a potentially degraded object (e.g., missing shards).
	RepairObject(context.Context, *RepairObjectRequest) (*ResilienceOperationResponse, error)
	// UpdateObjectPlacementPolicy updates the placement policy for an object or a class of objects.
	UpdateObjectPlacementPolicy(context.Context, *UpdatePlacementPolicyRequest) (*ResilienceOperationResponse, error)
	// GetStorageNodeHealth allows querying health of individual storage nodes participating in Storj/IPFS.
	GetStorageNodeHealth(context.Context, *StorageNodeHealthRequest) (*StorageNodeHealthResponse, error)
	mustEmbedUnimplementedResilienceServiceServer()
}

// UnimplementedResilienceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedResilienceServiceServer struct{}

func (UnimplementedResilienceServiceServer) StoreObject(context.Context, *StoreObjectRequest) (*StoreObjectResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StoreObject not implemented")
}
func (UnimplementedResilienceServiceServer) RetrieveObject(*RetrieveObjectRequest, grpc.ServerStreamingServer[ObjectChunk]) error {
	return status.Errorf(codes.Unimplemented, "method RetrieveObject not implemented")
}
func (UnimplementedResilienceServiceServer) DeleteObject(context.Context, *DeleteObjectRequest) (*ResilienceOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteObject not implemented")
}
func (UnimplementedResilienceServiceServer) GetObjectStatus(context.Context, *GetObjectStatusRequest) (*GetObjectStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetObjectStatus not implemented")
}
func (UnimplementedResilienceServiceServer) RepairObject(context.Context, *RepairObjectRequest) (*ResilienceOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RepairObject not implemented")
}
func (UnimplementedResilienceServiceServer) UpdateObjectPlacementPolicy(context.Context, *UpdatePlacementPolicyRequest) (*ResilienceOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateObjectPlacementPolicy not implemented")
}
func (UnimplementedResilienceServiceServer) GetStorageNodeHealth(context.Context, *StorageNodeHealthRequest) (*StorageNodeHealthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStorageNodeHealth not implemented")
}
func (UnimplementedResilienceServiceServer) mustEmbedUnimplementedResilienceServiceServer() {}
func (UnimplementedResilienceServiceServer) testEmbeddedByValue()                           {}

// UnsafeResilienceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ResilienceServiceServer will
// result in compilation errors.
type UnsafeResilienceServiceServer interface {
	mustEmbedUnimplementedResilienceServiceServer()
}

func RegisterResilienceServiceServer(s grpc.ServiceRegistrar, srv ResilienceServiceServer) {
	// If the following call pancis, it indicates UnimplementedResilienceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ResilienceService_ServiceDesc, srv)
}

func _ResilienceService_StoreObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StoreObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResilienceServiceServer).StoreObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResilienceService_StoreObject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResilienceServiceServer).StoreObject(ctx, req.(*StoreObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResilienceService_RetrieveObject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RetrieveObjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ResilienceServiceServer).RetrieveObject(m, &grpc.GenericServerStream[RetrieveObjectRequest, ObjectChunk]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ResilienceService_RetrieveObjectServer = grpc.ServerStreamingServer[ObjectChunk]

func _ResilienceService_DeleteObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResilienceServiceServer).DeleteObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResilienceService_DeleteObject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResilienceServiceServer).DeleteObject(ctx, req.(*DeleteObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResilienceService_GetObjectStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetObjectStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResilienceServiceServer).GetObjectStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResilienceService_GetObjectStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResilienceServiceServer).GetObjectStatus(ctx, req.(*GetObjectStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResilienceService_RepairObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepairObjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResilienceServiceServer).RepairObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResilienceService_RepairObject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResilienceServiceServer).RepairObject(ctx, req.(*RepairObjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResilienceService_UpdateObjectPlacementPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePlacementPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResilienceServiceServer).UpdateObjectPlacementPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResilienceService_UpdateObjectPlacementPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResilienceServiceServer).UpdateObjectPlacementPolicy(ctx, req.(*UpdatePlacementPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResilienceService_GetStorageNodeHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StorageNodeHealthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResilienceServiceServer).GetStorageNodeHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResilienceService_GetStorageNodeHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResilienceServiceServer).GetStorageNodeHealth(ctx, req.(*StorageNodeHealthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ResilienceService_ServiceDesc is the grpc.ServiceDesc for ResilienceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ResilienceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "blackice.v1.ResilienceService",
	HandlerType: (*ResilienceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StoreObject",
			Handler:    _ResilienceService_StoreObject_Handler,
		},
		{
			MethodName: "DeleteObject",
			Handler:    _ResilienceService_DeleteObject_Handler,
		},
		{
			MethodName: "GetObjectStatus",
			Handler:    _ResilienceService_GetObjectStatus_Handler,
		},
		{
			MethodName: "RepairObject",
			Handler:    _ResilienceService_RepairObject_Handler,
		},
		{
			MethodName: "UpdateObjectPlacementPolicy",
			Handler:    _ResilienceService_UpdateObjectPlacementPolicy_Handler,
		},
		{
			MethodName: "GetStorageNodeHealth",
			Handler:    _ResilienceService_GetStorageNodeHealth_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RetrieveObject",
			Handler:       _ResilienceService_RetrieveObject_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "blackice/proto/blackice/v1/resilience.proto",
}
